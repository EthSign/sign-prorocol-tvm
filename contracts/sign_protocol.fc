#pragma version >=0.3.0;

#include "../node_modules/@ston-fi/funcbox/autoload.fc";

#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";
#include "imports/definitions.fc";

#include "operations/hash_ops.fc";
#include "operations/helper_ops.fc";
#include "operations/register_ops.fc";
#include "operations/attest_ops.fc";
#include "operations/revoke_ops.fc";

;; =============== storage =============================

;; load_data populates storage variables using stored data
() load_data() impure {
  var ds = get_data().begin_parse();

  version = ds~load_uint(64);
  admin_address = ds~load_msg_addr();
  paused = ds~load_uint(1);
  schema_counter = ds~load_uint(64);
  attestation_counter = ds~load_uint(64);
  initial_schema_counter = ds~load_uint(64);
  initial_attestation_counter = ds~load_uint(64);
  attestation_code = ds~load_ref();
  attestation_offchain_code = ds~load_ref();
  schema_code = ds~load_ref();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data (int version, slice admin_address, int paused, int schema_counter, int attestation_counter, int initial_schema_counter, int initial_attestation_counter, cell attestation_code, cell attestation_offchain_code, cell schema_code) impure {
  set_data(
    begin_cell()
      .store_uint(version, 64)
      .store_slice(admin_address)
      .store_uint(paused, 1)
      .store_uint(schema_counter, 64)
      .store_uint(attestation_counter, 64)
      .store_uint(initial_schema_counter, 64)
      .store_uint(initial_attestation_counter, 64)
      .store_uint(version, 64)
      .store_ref(attestation_code)
      .store_ref(attestation_offchain_code)
      .store_ref(schema_code)
      .end_cell()
  );
}

;; =============== messages =============================

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(slice in_msg) impure {
  if (in_msg.slice_empty?()) { ;; ignore all empty messages
    return ();
  }

  int flags = in_msg~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  int op = in_msg~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
  int query_id = in_msg~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case
  slice sender_address = in_msg~load_msg_addr();
  load_data();

  if (op == op::change_admin) {
    throw_unless(error::unauthorized, equal_slices(sender_address, admin_address));

    slice new_admin_address = in_msg~load_msg_addr();

    save_data(version, new_admin_address, paused, schema_counter, attestation_counter, initial_schema_counter, initial_attestation_counter, attestation_code, attestation_offchain_code, schema_code);
    return ();
  }

  if (op == op::change_paused) {
    throw_unless(error::unauthorized, equal_slices(sender_address, admin_address));

    int _paused = in_msg~load_uint(1);

    save_data(version, admin_address, _paused, schema_counter, attestation_counter, initial_schema_counter, initial_attestation_counter, attestation_code, attestation_offchain_code, schema_code);
    return ();
  }

  throw(error::unknown_op); ;; if the message contains an op that is not known to this contract, we throw
}

() recv_external(slice in_msg) impure {
  ;; var signature = in_msg~load_bits(32);
  ;; var cs = in_msg;
  ;; var (valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32));

  ;; throw_if(error::expired_message, valid_until <= now());

  ;; load_data();

  ;; throw_unless(error::repeated_message, msg_seqno == cur_seqno);
  ;; accept_message();
  ;; save_data(version, admin_address, paused, schema_counter, attestation_counter, initial_schema_counter, initial_attestation_counter, attestation_code, attestation_offchain_code, schema_code, cur_seqno + 1);
  ;; commit();
  ;; cs~touch();

  ;; slice sender_address = cs~load_msg_addr();
  ;; int pubkey = cs~load_uint(32);
  ;; int op = cs~load_uint(32);

  ;; throw_unless(error::invalid_signature, check_signature(slice_hash(in_msg), signature, pubkey));
  
  ;; throw(error::unknown_op); ;; if the message contains an op that is not known to this contract, we throw
}

;; =============== getter functions =============================

int get_paused() method_id {
  load_data();

  return paused;
}

int get_version() method_id {
  load_data();

  return version;
}

int get_schema_counter() method_id {
  load_data();

  return schema_counter;
}

int get_attestation_counter() method_id {
  load_data();
  
  return attestation_counter;
}
